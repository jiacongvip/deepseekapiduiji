# 豆包搜索引用网站功能说明

## 功能概述

现在API已经支持获取豆包搜索时引用的网站列表，可以看到豆包回答时参考了哪些网页。

## 更新内容

### 1. 响应模型更新

新增 `ReferenceItem` 模型和 `references` 字段：

```python
class ReferenceItem(BaseModel):
    """引用来源项"""
    title: str          # 网站标题
    url: str            # 网站URL
    snippet: str        # 摘要/片段（可选）
    index: int          # 引用序号（可选）

class CompletionResponse(BaseModel):
    text: str                          # 回复文本
    img_urls: List[str]                # 图片URL列表
    references: List[ReferenceItem]    # 引用的网站列表 ⭐新增
    conversation_id: str               # 对话ID
    messageg_id: str                   # 消息ID
    section_id: str                    # 段落ID
```

### 2. API响应示例

#### 请求示例

```bash
curl -X POST "http://localhost:8000/api/chat/completions" \
  -H "Content-Type: application/json" \
  -d '{
    "prompt": "2026年最新的AI技术发展趋势是什么？",
    "guest": false
  }'
```

#### 响应示例（包含引用）

```json
{
  "text": "根据最新的技术报告，2026年AI技术发展主要有以下趋势...",
  "img_urls": [],
  "references": [
    {
      "title": "常州做小程序_微信小程序定制开发_APP网站制作_飞傲软件公司",
      "url": "http://www.fiaoo.com/",
      "snippet": "常州飞傲软件科技有限公司是常州本地提供小程序开发，软件APP定制...",
      "index": 1,
      "sitename": "常州飞傲软件科技有限公司",
      "publish_time": "2025-10-29T07:50:20+08:00"
    },
    {
      "title": "常州小程序开发公司排名(排行榜) - 职友集",
      "url": "https://m.jobui.com/rank/company/view/changzhou/xiaochengxukaifa/",
      "snippet": "江苏嗨购网络科技有限公司，5.6万次浏览...",
      "index": 2,
      "sitename": "职友集",
      "publish_time": "2025-08-21T15:15:33+08:00"
    }
  ],
  "conversation_id": "7123456789",
  "messageg_id": "msg_abc123",
  "section_id": "sec_xyz789"
}
```

## 使用场景

### 1. 获取信息来源

当豆包进行搜索回答时，你可以获取它引用的网站：

```python
import requests

response = requests.post(
    "http://localhost:8000/api/chat/completions",
    json={
        "prompt": "最近的科技新闻有哪些？",
        "guest": False
    }
)

data = response.json()
print("回答:", data['text'])
print("\n参考网站:")
for ref in data['references']:
    print(f"  [{ref.get('index', '?')}] {ref['title']}")
    print(f"      来源: {ref.get('sitename', '未知')}")
    print(f"      URL: {ref['url']}")
    print(f"      摘要: {ref.get('snippet', '')[:100]}...")
    if ref.get('publish_time'):
        print(f"      发布: {ref['publish_time']}")
```

### 2. 验证信息可靠性

通过引用列表，可以验证豆包回答的来源：

```python
references = data['references']
if references:
    print(f"本次回答引用了 {len(references)} 个网站:")
    for ref in references:
        print(f"  - {ref['title']}: {ref['url']}")
else:
    print("本次回答未使用网络搜索")
```

### 3. 自动生成参考文献

可以用于自动生成学术风格的参考文献：

```python
def format_references(references):
    """格式化为参考文献列表"""
    result = ["## 参考文献\n"]
    for i, ref in enumerate(references, 1):
        result.append(f"[{i}] {ref['title']}. {ref['url']}")
    return "\n".join(result)

references_text = format_references(data['references'])
print(references_text)
```

## 实现原理

### SSE流解析

豆包的搜索结果实际上是通过 `patch_op` 或 `content_block` 传递的。数据结构如下：

#### 真实数据结构

```json
{
  "patch_op": [{
    "patch_type": 1,
    "patch_value": {
      "content_block": [{
        "block_type": 10025,  // 搜索结果块
        "content": {
          "search_query_result_block": {
            "summary": "搜索 2 个关键词，参考 10 篇资料",
            "queries": ["关键词1", "关键词2"],
            "results": [{
              "text_card": {
                "title": "网站标题",
                "url": "https://example.com",
                "summary": "摘要内容",
                "sitename": "网站名",
                "publish_time_second": "2025-10-29T07:50:20+08:00",
                "index": 1
              }
            }]
          }
        }
      }]
    }
  }]
}
```

#### 解析代码

```python
# 1. 处理 patch_op 结构
patch_ops = evt_obj.get('patch_op', [])
for patch_op in patch_ops:
    if patch_op.get('patch_type') == 1:
        content_blocks = patch_op.get('patch_value', {}).get('content_block', [])
        
        for block in content_blocks:
            # block_type: 10025 表示搜索结果块
            if block.get('block_type') == 10025:
                search_result = block.get('content', {}).get('search_query_result_block', {})
                results = search_result.get('results', [])
                
                for result in results:
                    text_card = result.get('text_card', {})
                    if text_card:
                        ref_data = {
                            'title': text_card.get('title', ''),
                            'url': text_card.get('url', ''),
                            'snippet': text_card.get('summary', ''),
                            'index': text_card.get('index'),
                            'sitename': text_card.get('sitename', ''),
                            'publish_time': text_card.get('publish_time_second', '')
                        }
                        references.append(ref_data)

# 2. 也检查 message.content_block（备用路径）
content_blocks = msg.get('content_block', [])
# ... 同样的解析逻辑
```

### 数据流程

```
1. 用户发送搜索相关问题
   ↓
2. 豆包进行网络搜索
   ↓
3. 返回SSE流式响应
   └─ event_type: 2001 (消息)
      └─ message
         ├─ content (文本内容)
         └─ references (引用列表) ⭐
   ↓
4. 解析references字段
   ↓
5. 返回包含引用的完整响应
```

## 注意事项

### 1. 并非所有回答都有引用

- ✅ 涉及搜索的问题：会返回引用列表
- ❌ 一般知识问答：`references` 为空列表
- ❌ 创意写作等：`references` 为空列表

### 2. 引用数量不固定

```json
// 可能返回 0 个引用
"references": []

// 可能返回多个引用
"references": [
  {"title": "...", "url": "..."},
  {"title": "...", "url": "..."},
  {"title": "...", "url": "..."}
]
```

### 3. 字段可选性

`ReferenceItem` 中的字段：
- `title`: 必填 - 网站标题
- `url`: 必填 - 网站链接
- `snippet`: 可选 - 内容摘要
- `index`: 可选 - 引用序号
- `sitename`: 可选 - 网站名称（⭐新增）
- `publish_time`: 可选 - 发布时间（⭐新增）

## 测试建议

### 容易触发引用的问题类型

1. **最新信息查询**
   ```
   "2026年1月的最新科技新闻"
   "今天的天气怎么样？"
   ```

2. **事实性信息**
   ```
   "某某公司的最新财报"
   "某个城市的人口数量"
   ```

3. **实时数据**
   ```
   "当前比特币价格"
   "最新的股市行情"
   ```

### 不太会触发引用的问题

1. **常识性问题**
   ```
   "什么是Python？"
   "如何学习编程？"
   ```

2. **创意性任务**
   ```
   "帮我写一首诗"
   "给我讲个故事"
   ```

## 完整示例代码

### Python示例

```python
import requests
import json

def chat_with_references(prompt: str):
    """发送聊天请求并获取引用"""
    url = "http://localhost:8000/api/chat/completions"
    
    payload = {
        "prompt": prompt,
        "guest": False,
        "conversation_id": None,
        "section_id": None,
        "attachments": [],
        "use_auto_cot": False,
        "use_deep_think": False
    }
    
    response = requests.post(url, json=payload)
    data = response.json()
    
    print("=" * 60)
    print("问题:", prompt)
    print("=" * 60)
    print("\n【回答】")
    print(data['text'])
    
    if data['references']:
        print("\n【参考来源】")
        for i, ref in enumerate(data['references'], 1):
            print(f"\n[{i}] {ref['title']}")
            print(f"    URL: {ref['url']}")
            if ref.get('snippet'):
                print(f"    摘要: {ref['snippet'][:100]}...")
    else:
        print("\n【参考来源】: 无（未使用网络搜索）")
    
    print("\n" + "=" * 60)
    
    return data

# 测试
if __name__ == "__main__":
    # 测试1: 实时信息查询（应该有引用）
    chat_with_references("2026年1月13日的科技新闻")
    
    # 测试2: 常识问题（可能无引用）
    chat_with_references("什么是人工智能？")
```

### JavaScript示例

```javascript
async function chatWithReferences(prompt) {
    const response = await fetch('http://localhost:8000/api/chat/completions', {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json',
        },
        body: JSON.stringify({
            prompt: prompt,
            guest: false,
            conversation_id: null,
            section_id: null,
            attachments: [],
            use_auto_cot: false,
            use_deep_think: false
        })
    });
    
    const data = await response.json();
    
    console.log('问题:', prompt);
    console.log('\n回答:', data.text);
    
    if (data.references.length > 0) {
        console.log('\n参考来源:');
        data.references.forEach((ref, index) => {
            console.log(`[${index + 1}] ${ref.title}`);
            console.log(`    ${ref.url}`);
        });
    } else {
        console.log('\n参考来源: 无');
    }
    
    return data;
}

// 使用示例
chatWithReferences('2026年最新的AI发展趋势');
```

## API文档更新

访问 http://localhost:8000/docs 可以查看更新后的API文档，其中会显示新增的 `references` 字段。

## 总结

✅ **已实现功能**:
- 自动提取豆包搜索时的引用网站
- 返回标题、URL、摘要等信息
- 支持多个引用来源
- 兼容无引用的普通回答

✅ **使用场景**:
- 验证信息来源
- 获取参考文献
- 评估回答可靠性
- 延伸阅读

✅ **兼容性**:
- 向下兼容（原有功能不受影响）
- 对于无引用的回答，`references` 返回空数组
- 不影响现有的聊天功能

---

*文档更新时间: 2026-01-13*
*功能版本: v0.2.1*

